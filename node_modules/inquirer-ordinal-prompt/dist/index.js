"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const cliCursor = require("cli-cursor");
const figures = require("figures");
const operators_1 = require("rxjs/operators");
const Base = require("inquirer/lib/prompts/base");
const observe = require("inquirer/lib/utils/events");
const Paginator = require("inquirer/lib/utils/paginator");
class OrdinalPrompt extends Base {
    constructor(question, rl, answers) {
        super(question, rl, answers);
        this.firstRender = true;
        this.values = [];
        if (!this.opt.choices) {
            this.throwParamError('choices');
        }
        if (Array.isArray(this.opt.default)) {
            this.values = this.opt.default.reduce((accum, value) => {
                if (this.opt.choices.find({ value })) {
                    return updateSelectedValues(accum, value);
                }
                return accum;
            }, []);
        }
        this.pointer = 0;
        // Make sure no default is set (so it won't be printed)
        this.opt.default = null;
        this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param cb - Callback when prompt is done
     */
    _run(cb) {
        this.done = cb;
        const events = observe(this.rl);
        const validation = this.handleSubmitEvents(events.line.pipe(operators_1.map(this.getCurrentValue.bind(this))));
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));
        events.normalizedUpKey
            .pipe(operators_1.takeUntil(validation.success))
            .forEach(this.onUpKey.bind(this));
        events.normalizedDownKey
            .pipe(operators_1.takeUntil(validation.success))
            .forEach(this.onDownKey.bind(this));
        events.numberKey
            .pipe(operators_1.takeUntil(validation.success))
            .forEach(this.onNumberKey.bind(this));
        events.spaceKey
            .pipe(operators_1.takeUntil(validation.success))
            .forEach(this.onSpaceKey.bind(this));
        events.keypress
            .pipe(operators_1.filter(({ key }) => key && key.name === 'r'), operators_1.share())
            .pipe(operators_1.takeUntil(validation.success))
            .forEach(this.onResetKey.bind(this));
        // Init the prompt
        cliCursor.hide();
        this.render();
        this.firstRender = false;
        return this;
    }
    /**
     * Render the prompt to screen
     */
    render(error) {
        // Render question
        let message = this.getQuestion();
        let bottomContent = '';
        if (!this.spaceKeyPressed) {
            message += `(Press ${chalk.cyan.bold('<space>')} to select, ${chalk.cyan.bold('<r>')} to reset)`;
        }
        // Render choices or answer depending on the state
        if (this.status === 'answered') {
            message += chalk.cyan(this.values.join(', '));
        }
        else {
            const choicesStr = renderChoices(this.opt.choices, this.values, this.pointer);
            const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.pointer));
            message += `\n${this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize)}`;
        }
        if (error) {
            bottomContent = `${chalk.red('>> ')}${error}`;
        }
        this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    onEnd(state) {
        this.status = 'answered';
        this.spaceKeyPressed = true;
        // Rerender prompt (and clean subline error)
        this.render();
        this.screen.done();
        cliCursor.show();
        this.done(state.value);
    }
    onError(state) {
        this.render(state.isValid);
    }
    getCurrentValue() {
        const choices = this.values.filter((value) => {
            const choice = this.opt.choices.find({ value });
            return choice && !choice.disabled;
        });
        return choices;
    }
    onUpKey() {
        const len = this.opt.choices.realLength;
        this.pointer = this.pointer > 0 ? this.pointer - 1 : len - 1;
        this.render();
    }
    onDownKey() {
        const len = this.opt.choices.realLength;
        this.pointer = this.pointer < len - 1 ? this.pointer + 1 : 0;
        this.render();
    }
    onNumberKey(input) {
        if (input <= this.opt.choices.realLength) {
            this.pointer = input - 1;
            this.toggleChoice(this.pointer);
        }
        this.render();
    }
    onSpaceKey() {
        this.spaceKeyPressed = true;
        this.toggleChoice(this.pointer);
        this.render();
    }
    onResetKey() {
        this.values = [];
        this.render();
    }
    toggleChoice(index) {
        const item = this.opt.choices.getChoice(index);
        if (item) {
            this.values = updateSelectedValues(this.values, item.value);
        }
    }
}
exports.OrdinalPrompt = OrdinalPrompt;
/**
 * Function for rendering ordinal choices
 * @param choices - List of prompt options
 * @param values - Ordered list of selected values
 * @param pointer - Position of the pointer
 * @return Rendered content
 */
function renderChoices(choices, values, pointer) {
    let output = '';
    let separatorOffset = 0;
    choices.forEach((choice, i) => {
        if (choice.type === 'separator') {
            separatorOffset++;
            output += ` ${choice}\n`;
            return;
        }
        if (choice.disabled) {
            separatorOffset++;
            output += ` - ${choice.name}`;
            output += ` (${typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'})`;
        }
        else {
            const line = `${getItemIndexOrBox(values.indexOf(choice.value))} ${choice.name}`;
            if (i - separatorOffset === pointer) {
                output += chalk.cyan(figures.pointer + line);
            }
            else {
                output += ` ${line}`;
            }
        }
        output += '\n';
    });
    return output.replace(/\n$/, '');
}
/**
 * Get the index
 * @param index - add ordinal or not to the checkbox
 * @return Composited checkbox string
 */
function getItemIndexOrBox(index) {
    return index >= 0 ? chalk.green(index + 1) : figures.radioOff;
}
/**
 * Update selected choices
 * @param values - ordered list of selected choices
 * @param newValue - choice to toggle
 * @returns Ordered list of selected choices
 */
function updateSelectedValues(values, newValue) {
    if (values.includes(newValue)) {
        return values.filter((v) => v !== newValue);
    }
    return [...values, newValue];
}
exports.default = OrdinalPrompt;
//# sourceMappingURL=index.js.map